#!/usr/bin/env python3

from threading import Lock
from typing import Optional, Tuple

import gtsam
import gtsam_quadrics
import message_filters
import numpy as np
from ros_numpy import numpify
import rospy
from sensor_msgs.msg import CameraInfo, Image
from spatialmath import SE3

from quadricslam import (DataSource, QuadricSlam, QuadricSlamState, utils,
                         visualise)
from quadricslam.data_associator.quadric_iou_associator import QuadricIouAssociator
from quadricslam.detector.faster_rcnn import FasterRcnn


class RealSenseRos(DataSource):

    def __init__(self) -> None:
        self.sub_depth = message_filters.Subscriber('/depth', Image)
        self.sub_rgb = message_filters.Subscriber('/rgb', Image)

        ci: CameraInfo = rospy.wait_for_message('/rgb_info', CameraInfo)
        self._calib_rgb = np.array([ci.K[0], ci.K[4], 1, ci.K[2], ci.K[5]])

        self.msgs = None
        self.msgs_lock = Lock()

        self.ts = message_filters.TimeSynchronizer(
            [self.sub_depth, self.sub_rgb], 10)
        self.ts.registerCallback(self.callback)

    def callback(self, depth: Image, rgb: Image):
        with self.msgs_lock:
            self.msgs = (depth, rgb)

    def calib_rgb(self) -> np.ndarray:
        return self._calib_rgb

    def done(self) -> bool:
        return False

    def next(
        self, state: QuadricSlamState
    ) -> Tuple[Optional[SE3], Optional[np.ndarray], Optional[np.ndarray]]:
        with self.msgs_lock:
            return ((None, None, None) if self.msgs is None else
                    (None, numpify(self.msgs[1]), numpify(self.msgs[0])))

    def restart(self) -> None:
        pass


def run():
    q = QuadricSlam(
        data_source=RealSenseRos(),
        detector=FasterRcnn(),
        associator=QuadricIouAssociator(),
        optimiser_batch=False,
        on_new_estimate=(
            lambda state: visualise(state.system.estimates, state.system.
                                    labels, state.system.optimiser_batch)),
        quadric_initialiser=utils.initialise_quadric_from_depth)
    q.spin()


if __name__ == '__main__':
    run()
